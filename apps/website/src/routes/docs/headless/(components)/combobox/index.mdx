---
title: Qwik UI | Combobox
---

import {
  Combobox,
  ComboboxLabel,
  ComboboxTrigger,
  ComboboxInput,
  ComboboxListbox,
  ComboboxOption,
} from '@qwik-ui/headless';

import { HeroExample, StringCombobox, ObjectCombobox, CustomFilter, SortingExample, DisabledExample, CustomKeysExample, DisableBlur, PlacementExample, FlipExample, GutterExample, HideExample, AnimationExample, CustomState, DefaultLabel, HighlightedExample, SearchBar, AutoPlacementExample, ContextChild } from './examples';
import { CodeExample } from '../../../_components/code-example/code-example';
import { KeyboardInteractionTable } from '../../../_components/keyboard-interaction-table/keyboard-interaction-table';
import { APITable } from '../../../_components/api-table/api-table';
import { StatusBanner } from '../../../_components/status-banner/status-banner';
import {statusByComponent} from '../../../../../_state/component-statuses';
import { AnatomyTable } from '../../../_components/anatomy-table/anatomy-table';

<StatusBanner status={statusByComponent.headless.Combobox} />

# Combobox

A customizable text field with a listbox, enabling users to constrain a list of choices based on their search criteria.

{' '}

<HeroExample>
  ```tsx
const objectExample = [
  { testValue: 'alice', testLabel: 'Alice', disabled: true },
  { testValue: 'joana', testLabel: 'Joana', disabled: true },
  { testValue: 'malcolm', testLabel: 'Malcolm', disabled: false },
  { testValue: 'zack', testLabel: 'Zack', disabled: true },
  { testValue: 'brian', testLabel: 'Brian', disabled: false },
  { testValue: 'ryan', testLabel: 'Ryan', disabled: false },
  { testValue: 'joe', testLabel: 'Joe', disabled: false },
  { testValue: 'randy', testLabel: 'Randy', disabled: false },
  { testValue: 'david', testLabel: 'David', disabled: true },
  { testValue: 'joseph', testLabel: 'Joseph', disabled: false },
];

export const HeroExample = component$(() => {
  type MyData = {
    testValue: string;
    testLabel: string;
    disabled: boolean;
  };

  return (
    <>
          <Combobox
            options={objectExample}
            optionValueKey="testValue"
            optionLabelKey="testLabel"
            optionDisabledKey="disabled"
            class="relative"
          >
            <ComboboxLabel class=" font-semibold text-white">
              Personal Trainers ‚ö°
            </ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput
                placeholder="Jim"
                class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500"
              />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => {
                  const myData = option.option as MyData;
                  return (
                    <ComboboxOption
                      key={option.key}
                      resolved={option}
                      index={index}
                      class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    >
                      <span class="block group-aria-selected:translate-x-[3px] transition-transform duration-350">
                        {myData.testLabel}
                      </span>
                    </ComboboxOption>
                  );
                }}
              />
            </ComboboxPortal>
          </Combobox>
        </div>

        </div>
      </PreviewCodeExample>
    </>
  );
});
  ```
</HeroExample>

Qwik UI's Combobox implementation follows the [WAI-Aria Combobox specifications](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/), along with some additional API's that enhance the flexibility, types, and performance.

<div class="mb-6 flex flex-col gap-2">
[View Source Code ‚ÜóÔ∏è](https://github.com/qwikifiers/qwik-ui/tree/main/packages/kit-headless/src/components/combobox)

[Report an issue üö®](https://github.com/qwikifiers/qwik-ui/issues)

[Edit This Page üóíÔ∏è](<https://github.com/qwikifiers/qwik-ui/edit/main/apps/website/src/routes/docs/headless/(components)/combobox/index.mdx>)

</div>

<br />

## ‚ú® Features

- Full WAI-Aria compliance
- Full keyboard navigation
- Custom Autocomplete behavior
- Custom filter functionality
- Controlled or uncontrolled
- Supports disabled options
- Custom signal binds
- Animatable, dynamic, and resumable

<br/>

> In Beta, we're currently supporting the **`Autocomplete`** configuration. We aim to support other combobox configurations according to our [roadmap](https://github.com/qwikifiers/qwik-ui/issues/405)

<br />

<div class="bg-slate-200 dark:bg-slate-800 border-2 border-slate-500 p-4 lg:p-6 rounded-xl shadow-light-medium dark:shadow-dark-medium">
  <p class="pb-4">The Combobox component makes use of <a class="border-b-2 !border-qwikui-blue-400 dark:border-qwikui-purple-500" href="https://qwik.builder.io/docs/cookbook/portal/#portal">portals</a>. A basic use case for a portal is to prevent overflow issues in your UI. To support portals in Qwik UI, please add the following around your layout.tsx.</p>
  <CodeExample classes="!mb-0 !p-6 !rounded-md">
    ```tsx
    import { QwikUIProvider } from '@qwik-ui/headless'; // import Provider component

    // wrap as a direct child to the body tag
    <body>
      <QwikUIProvider>
        <Slot />
      </QwikUIProvider>
    </body>
    ```
  </CodeExample>

  <div class="pt-12 pb-4">
    ### <ins>**Context Caveats**</ins>
    <p class="pt-2 pb-4">Portals are still currently in **Beta**, as a result, you may experience an issue using your own context to pass data into the portal children.</p>
    <p class="pb-4">If you do experience any context related issues, add the following **contextIds** prop to the **ComboboxPortal** component. It takes in an array of string context id's as a prop. We also have a live example below with context.</p>
    <p class="pb-4">If you are not using context inside the portal children, this will not be an issue.</p>

      <CodeExample classes="!mb-0 !p-6 !rounded-md">
      ```tsx
        <ComboboxPortal contextIds={["my-context-id", "my-context-id-2"]}>
          <ComboboxListbox>
            <ComboboxOption>Option</ComboboxOption>
          </ComboboxListbox>
        </ComboboxPortal> 
      ```
    </CodeExample>
  </div>
</div>

<br/>

## Building blocks

  <CodeExample>
    ```tsx
    import { component$ } from '@builder.io/qwik';
    import { Combobox, ComboboxLabel, ComboboxControl, ComboboxInput, ComboboxTrigger, ComboboxPortal, ComboboxListbox, ComboboxOption } from '@qwik-ui/headless';

    export default component$(() => {
      return (
        <Combobox>
          <ComboboxLabel>Label Element</ComboboxLabel>
          <ComboboxControl>
            <ComboboxInput />
            <ComboboxTrigger>
              Opens Listbox
            </ComboboxTrigger>
          </ComboboxControl>
          <ComboboxPortal>
            <ComboboxListbox 
            optionRenderer$={() => (
              <ComboboxOption>
                Option Label
              </ComboboxOption>
            )} />
          </ComboboxPortal>
        </Combobox>
      )
    ```
  </CodeExample>

  ### üé® Anatomy
  <AnatomyTable
  propDescriptors={[
    {
      name: 'Combobox',
      description: 'The root container for the Combobox.',
    },
    {
      name: 'ComboboxLabel',
      description: 'A label element to connect to the Combobox.',
    },
    {
      name: 'ComboboxControl',
      description: `A container for the combobox trigger, and input.`,
    },
    {
      name: 'ComboboxInput',
      description: `An input element used for filtering, and controlling the combobox state.`,
    },
    {
      name: 'ComboboxTrigger',
      description: `A button that toggles the corresponding listbox when clicked.`,
    },
    {
      name: 'ComboboxPortal',
      description: `A portal component that teleports the children outside its parent when the listbox state is open.`,
    },
    {
      name: 'ComboboxListbox',
      description: `An unordered list that contains multiple options that display when opened.`,
    },
    {
      name: 'ComboboxOption',
      description: `A list item that is shown based on the listbox state and filter API.`,
    },
  ]}
/>

## Passing data

Qwik UI's Combobox supports **both** string and option data. Whether that's an array of strings, or an array of objects. To pass in data, add the `options` prop on the Combobox Root.

### String example

<StringCombobox>
```tsx
export const StringCombobox = component$(() => {
  const fruits = [
    'Apple',
    'Apricot',
    'Avocado ü•ë',
    'Banana',
    'Bilberry',
    'Blackberry',
    'Blackcurrant',
    'Blueberry',
    'Boysenberry',
    'Currant',
    'Cherry',
    'Coconut',
    'Cranberry',
    'Cucumber',
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox
            class="w-fit"
            options={fruits}
            filter$={(value: string, options) =>
              options.filter(({ option }) => {
                return option.toLowerCase().startsWith(value.toLowerCase());
              })
            }
          >
            <ComboboxLabel class=" font-semibold text-white">Fruits üçì</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput
                class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500"
                placeholder="Papaya"
              />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div
      </div>
    </PreviewCodeExample>
  );
});
```
</StringCombobox>

Under the hood, the data passed in populates the listbox with options. To see options visually, add the `renderOption$` prop on the Combobox Listbox. This prop is a [QRL](https://qwik.builder.io/docs/advanced/qrl/#qrl), inside is a callback where the `ComboboxOption` component needs to be passed in.

### Object example

<ObjectCombobox>
```tsx
export const ObjectCombobox = component$(() => {
  type Jedi = {
    value: string;
    label: string;
  };

  const objectExample: Array<Jedi> = [
    { value: 'anakin', label: 'Anakin Skywalker' },
    { value: 'obi-wan', label: 'Obi-Wan Kenobi' },
    { value: 'mace', label: 'Mace Windu' },
    { value: 'yoda', label: 'Yoda' },
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox class="w-fit" options={objectExample}>
            <ComboboxLabel class=" font-semibold text-white">Jedi ‚öîÔ∏è</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div
      </div>
    </PreviewCodeExample>
  );
}); 
```
</ObjectCombobox>

The callback takes **two** parameters: 

- An object that holds the resolved option data.
- The option index.

The resolved object also holds:

- The key.
- Option Label.
- Option Value.
- Any disabled options.

Import the **ResolvedOption** type from Qwik UI and pass in the data according to the code block below.

<CodeExample>
  ```tsx
  import { ComboboxOption, type ResolvedOption } from '@qwik-ui/headless';

  renderOption$={(option: ResolvedOption, index: number) => (
    <ComboboxOption
      key={option.key}
      index={index}
      resolved={option}
    >
      {option.label}
    </ComboboxOption>
  )}
  ```
</CodeExample>

## Adding a filter

Out of the box, the Combobox comes with a default filter that uses the **string.includes** method to filter options. To add a custom filter, you can use the `filter$` QRL.

<CustomFilter>
```tsx 
export const CustomFilter = component$(() => {
  type Countries = {
    value: string;
    label: string;
  };

  const objectExample: Array<Countries> = [
    { value: 'usa', label: 'United States' },
    { value: 'canada', label: 'Canada' },
    { value: 'mexico', label: 'Mexico' },
    { value: 'brazil', label: 'Brazil' },
    { value: 'uk', label: 'United Kingdom' },
    { value: 'germany', label: 'Germany' },
    { value: 'france', label: 'France' },
    { value: 'italy', label: 'Italy' },
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox
            class="w-fit"
            options={objectExample}
            filter$={(value: string, options) =>
              options.filter(({ option }) => {
                return option.label.toLowerCase().startsWith(value.toLowerCase());
              })
            }
          >
            <ComboboxLabel class=" font-semibold text-white">Countries üö©</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                flip={true}
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div
      </div>
    </PreviewCodeExample>
  );
});
```
</CustomFilter>

In this example, the filter function retrieves the input value and options object. It then filters the options using the JavaScript `string.startsWith` method as part of our filter logic. However, you are not limited to this method. You can use any filtering method of your choice to customize the behavior to suit your needs.

### Sorting

In our previous example, you may have noticed that the country data wasn't sorted alphabetically. To sort options, add an additional sort method after the filter.

<SortingExample>
```tsx 
export const SortingExample = component$(() => {
  type Countries = {
    value: string;
    label: string;
  };

  const objectExample: Array<Countries> = [
    { value: 'usa', label: 'United States' },
    { value: 'canada', label: 'Canada' },
    { value: 'mexico', label: 'Mexico' },
    { value: 'brazil', label: 'Brazil' },
    { value: 'uk', label: 'United Kingdom' },
    { value: 'germany', label: 'Germany' },
    { value: 'france', label: 'France' },
    { value: 'italy', label: 'Italy' },
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox
            class="w-fit"
            options={objectExample}
            filter$={(value: string, options) =>
              options
                .filter(({ option }) => {
                  return option.label.toLowerCase().startsWith(value.toLowerCase());
                })
                .sort((country1, country2) =>
                  country1.option.label.localeCompare(country2.option.label),
                )
            }
          >
            <ComboboxLabel class=" font-semibold text-white">Countries üö©</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                flip={true}
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div
      </div>
    </PreviewCodeExample>
  );
});
```
</SortingExample>

## Disabled Behavior

There are two ways to indicate that an option is disabled:

- Using the default **disabled** key.
- Passing a unique key name using the **optionDisabledKey** prop.

<DisabledExample>
```tsx 
export const DisabledExample = component$(() => {
  type DisabledExample = {
    value: string;
    label: string;
    myDisabledKey: boolean;
  };

  const disabledExample: Array<DisabledExample> = [
    { value: '0', label: 'Enabled', myDisabledKey: false },
    { value: '1', label: 'Enabled', myDisabledKey: false },
    { value: '2', label: 'Disabled', myDisabledKey: true },
    { value: '3', label: 'Enabled', myDisabledKey: false },
    { value: '4', label: 'Disabled', myDisabledKey: true },
    { value: '5', label: 'Disabled', myDisabledKey: true },
    { value: '6', label: 'Disabled', myDisabledKey: true },
    { value: '7', label: 'Enabled', myDisabledKey: false },
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox
            class="w-fit"
            options={disabledExample}
            optionDisabledKey="myDisabledKey"
          >
            <ComboboxLabel class=" font-semibold text-white">Disabled ‚õî</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                flip={true}
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div
      </div>
    </PreviewCodeExample>
  );
});
```
</DisabledExample>

The **optionDisabledKey** prop does not need to be passed when there is a key already named disabled, OR you do not have any disabled options.

## Custom Key Names

As we saw previously with the **optionDisabledKey** prop, custom key names can also be passed in for values and labels.

<CustomKeysExample>
```tsx 
export const CustomKeysExample = component$(() => {
  type Pokemon = {
    pokedex: string;
    pokemon: string;
    isPokemonCaught: boolean;
  };

  const pokemonExample: Array<Pokemon> = [
    { pokedex: '1', pokemon: 'Bulbasaur', isPokemonCaught: true },
    { pokedex: '2', pokemon: 'Ivysaur', isPokemonCaught: false },
    { pokedex: '3', pokemon: 'Venusaur', isPokemonCaught: false },
    { pokedex: '4', pokemon: 'Charmander', isPokemonCaught: true },
    { pokedex: '5', pokemon: 'Charmeleon', isPokemonCaught: true },
    { pokedex: '6', pokemon: 'Charizard', isPokemonCaught: true },
    { pokedex: '7', pokemon: 'Squirtle', isPokemonCaught: false },
    { pokedex: '8', pokemon: 'Wartortle', isPokemonCaught: false },
  ];

  const isPokemonCaught = useSignal(false);

  useVisibleTask$(({ track }) => {
    track(() => isPokemonCaught.value);
  });

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div class="relative">
          {isPokemonCaught.value && (
            <p class="absolute translate-x-[-105%] w-full text-white bg-slate-800 p-4 shadow-dark-medium rounded-md border-2 border-slate-400">
              You've already caught this pokemon!
            </p>
          )}
          <Combobox
            class="w-fit"
            options={pokemonExample}
            optionValueKey="pokedex"
            optionLabelKey="pokemon"
            optionDisabledKey="isPokemonCaught"
          >
            <ComboboxLabel class=" font-semibold text-white">Pokemon ü¶è</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                flip={true}
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => {
                  const pokemonOption = option.option as Pokemon;
                  return (
                    <ComboboxOption
                      key={option.key}
                      class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group flex justify-between"
                      index={index}
                      resolved={option}
                      onMouseEnter$={() => {
                        if (option.disabled === true) {
                          isPokemonCaught.value = true;
                        }
                      }}
                      onMouseLeave$={() => {
                        isPokemonCaught.value = false;
                      }}
                    >
                      <span>{pokemonOption.pokemon}</span>
                      <span>{pokemonOption.pokedex}</span>
                    </ComboboxOption>
                  );
                }}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</CustomKeysExample>

In some cases, your data object keys may not match the default keys that the Combobox component expects for option values and labels. By default, the Combobox component looks for keys named **value** for option values and **label** for option labels.

If your data object keys are different, you can specify custom key names using the `optionValueKey` and `optionLabelKey` props.

<CodeExample>
  ```tsx
    <Combobox
    options={myOptions}
    optionValueKey="pokedex"
    optionLabelKey="pokemon"
    optionDisabledKey="isPokemonCaught"
    />
  ```
</CodeExample>

Within our example, the value key is called **pokedex** and the label key is called **pokemon**. This tells the Combobox component to use the "pokedex" key for option values and the "pokemon" key for option labels.

> these props only need to be used if your data object keys **do not match** the default "value" and "label" keys. If your data object keys match these defaults, you do not need to pass in any custom keys.

## Configuring the Input

### Disabling Blur

The Qwik UI Combobox uses the `onBlur$ event` on the input to close the listbox when interacting with other elements.

<DisableBlur>
```tsx 
export const DisableBlur = component$(() => {
  const planets = [
    'Mercury',
    'Venus',
    'Earth',
    'Mars',
    'Jupiter',
    'Saturn',
    'Uranus',
    'Neptune',
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <p class="text-white text-center">
          I have blur disabled! Inspect me in the dev tools.
        </p>
        <div>
          <Combobox
            class="w-fit"
            options={planets}
            filter$={(value: string, options) =>
              options.filter(({ option }) => {
                return option.toLowerCase().startsWith(value.toLowerCase());
              })
            }
          >
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput
                disableOnBlur={true}
                class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500"
              />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                hide="referenceHidden"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</DisableBlur>

This can get tedious if certain custom behavior needs to be added, or the listbox needs to be inspected in the dev tools. 

To disable this behavior, set `disableOnBlur={true}` on the Input.

## **Configuring the Listbox**

The `ComboboxListbox` component is designed for positioning elements that float and facilitating interactions with them. The listbox is highly configurable, here are some example use cases:

### Placement

To set the default position of the listbox, you can use the `placement` prop. In the example below, we've set placement to top. When the user opens the listbox, it will be above the input.

<PlacementExample>
```tsx 
export const PlacementExample = component$(() => {
  const inputValueSig = useSignal('');
  type PlacementExample = {
    value: string;
    label: string;
  };

  const placementExample: Array<PlacementExample> = [
    { value: '0', label: 'Up' },
    { value: '1', label: 'Down' },
    { value: '2', label: 'Left' },
    { value: '3', label: 'Right' },
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div class="flex flex-col items-center">
          <p class="text-white text-center">Positions</p>
          <Combobox
            class="w-fit"
            options={placementExample}
            optionDisabledKey="myDisabledKey"
            bind:inputValueSig={inputValueSig}
          >
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative mt-2">
              <ComboboxInput class="w-44 px-2 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                placement="top"
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</PlacementExample>

The default placement is **bottom**.

### Flip

Allows the listbox to flip its position based on available space. It's enabled by default, but can be disabled by adding `flip={false}` on the listbox.

<FlipExample>
```tsx 
export const FlipExample = component$(() => {
  type FlipExample = {
    value: string;
    label: string;
  };

  const flipExample: Array<FlipExample> = [
    { value: '0', label: 'Up! ‚òùÔ∏è' },
    { value: '1', label: 'Up! ‚òùÔ∏è' },
    { value: '2', label: 'Down! üëá' },
    { value: '3', label: 'Up! ‚òùÔ∏è' },
    { value: '4', label: 'Down! üëá' },
    { value: '5', label: 'Down! üëá' },
    { value: '6', label: 'Down! üëá' },
    { value: '7', label: 'Up! ‚òùÔ∏è' },
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div class="flex flex-col items-center">
          <p class="text-white text-center">‚òùÔ∏è Scroll up and down with me open! üëá</p>
          <Combobox class="w-fit" options={flipExample} optionDisabledKey="myDisabledKey">
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative mt-2">
              <ComboboxInput class="w-44 px-2 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                flip={true}
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</FlipExample>
  
{
/* commented out for now
#### Shift
  
Enables the listbox to shift its position to prevent overflow.

<ShiftExample>```tsx ```</ShiftExample>
*/
}

### Gutter
  
In the previous docs examples, we use the gutter property on the listbox. Gutter is the space between the input and the floating element.

<GutterExample>
```tsx 
export const GutterExample = component$(() => {
  const streets = [
    'Baker Street',
    'Fleet Street',
    'Wall Street',
    'Broadway',
    'Sunset Boulevard',
    'Rodeo Drive',
    'Abbey Road',
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox
            class="w-fit"
            options={streets}
            filter$={(value: string, options) =>
              options.filter(({ option }) => {
                return option.toLowerCase().startsWith(value.toLowerCase());
              })
            }
          >
            <ComboboxLabel class="w-44 font-semibold text-white">
              I'm between gutters!
            </ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput
                class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500"
                placeholder="Wallaby Rd."
              />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={24}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</GutterExample>

If Flip is enabled, it will provide a gutter space for both the top and bottom.

### Animations <span class="ml-2 text-red-400 dark:text-red-500 text-base px-2 bg-red-100 rounded-md shadow-light-low dark:shadow-dark-medium border-b-2 border-[1px] border-red-200 dark:border-red-400">WIP</span>

We're still currently working to figure out animating things conditionally with portals. Would be open to some contributions on this!

<AnimationExample>
```tsx 
export const AnimationExample = component$(() => {
  const isListboxOpenSig = useSignal(false);

  const animationExample = [
    'Red',
    'Orange',
    'Yellow',
    'Green',
    'Blue',
    'Indigo',
    'Violet',
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox
            class="w-fit"
            options={animationExample}
            filter$={(value: string, options) =>
              options.filter(({ option }) => {
                return option.toLowerCase().startsWith(value.toLowerCase());
              })
            }
            bind:isListboxOpenSig={isListboxOpenSig}
          >
            <ComboboxLabel class=" font-semibold text-white">Streets üõ£Ô∏è</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput
                disableOnBlur={true}
                class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500"
                placeholder="Wallaby Rd."
              />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke-width="2"
                  class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                >
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                class={`w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px] transition-opacity duration-[500ms] ${
                  isListboxOpenSig.value ? 'opacity-100' : 'opacity-0'
                }`}
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</AnimationExample>

An idea here might be having an `isComboboxAnimatingSig` and changing that value based on the `onAnimationStart$` and `onAnimationEnd$` events before closing or opening the portal.

## Customizing State Signals

The Combobox component allows you to customize its state signals. This can be useful if you want to control or observe these states externally. 

This involves creating a signal and passing it in using the [bind syntax](https://qwik.builder.io/docs/components/rendering/#bind-attribute), such as in the Qwik docs.

<APITable
  propDescriptors={[
    {
      name: 'bind:isListboxOpenSig',
      type: 'Signal',
      description: 'Controls the open state of the listbox.',
    },
    {
      name: 'bind:isInputFocusedSig',
      type: 'Signal',
      description: 'Controls the focus state of the input.',
    },
    {
      name: 'bind:highlightedIndexSig',
      type: 'Signal',
      description: 'Controls which option is highlighted.',
    },
    {
      name: 'bind:inputValueSig',
      type: 'Signal',
      description: 'Controls the current value of the input.',
    },
  ]}
/>

Here is an example of how to customize these signals:

<CustomState>
```tsx 
export const CustomState = component$(() => {
  const isListboxOpenSig = useSignal(false);
  const highlightedIndexSig = useSignal(2);

  const signalsExample = [
    'bind:isListboxOpenSig',
    'bind:isInputFocusedSig',
    'bind:isTriggerFocusedSig',
    'bind:inputValueSig',
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <p class="text-white text-center">I love signals! üóº</p>
        <div>
          <Combobox
            class="w-fit"
            options={signalsExample}
            bind:isListboxOpenSig={isListboxOpenSig}
            bind:highlightedIndexSig={highlightedIndexSig}
          >
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput
                class="px-2 w-fit bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500"
                onClick$={() => (isListboxOpenSig.value = !isListboxOpenSig.value)}
              />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                class="w-fit bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                hide="escaped"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</CustomState>

When clicking on the input, it will now toggle the listbox. Signal binds are a useful toolbelt when customizing state is needed.

## Default Label

To set a default Label, pass the `defaultLabel` prop to the Combobox Root, along with the string label. This label connects to its proper option value, and highlights it accordingly.

<DefaultLabel>
```tsx 
export const DefaultLabel = component$(() => {
  const names = ['Jim', 'Joanna', 'John', 'Jessica'];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <div>
          <Combobox class="w-fit" defaultLabel={names[2]} options={names}>
            <ComboboxLabel class="text-white">Default Label</ComboboxLabel>
            <ComboboxControl class="bg-[#1f2532] rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput class="px-2 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                hide="escaped"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</DefaultLabel>

### Setting a default highlighted index

With the trick we learned about signal binds earlier, we can highlight an index by default, or customize the highlighted index based on user interaction.

<HighlightedExample>
```tsx 
export const HighlightedExample = component$(() => {
  const highlightedIndexSig = useSignal(2);

  const highlightedExample = [
    'not highlighted',
    'not highlighted',
    'highlighted by default!',
    'not highlighted',
  ];

  return 
      <div class="flex flex-col items-center gap-4 p-4" q:slot="actualComponent">
        <p class="text-white text-center">Third option highlighted! üö®</p>
        <div>
          <Combobox
            class="w-fit"
            options={highlightedExample}
            bind:highlightedIndexSig={highlightedIndexSig}
          >
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative">
              <ComboboxInput class="px-2 w-fit bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                gutter={8}
                size={true}
                class="w-fit bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                hide="escaped"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
      </div>
  );
});
```
</HighlightedExample>

## Search Bar

A common use case for an Autocomplete is a search bar. Here's an example of that using the Combobox.

<SearchBar>
```tsx
export const SearchBar = component$(() => {
  const inputValueSig = useSignal('');
  const highlightedIndexSig = useSignal(0);
  const inputRef = useSignal<HTMLInputElement>();
  const isListboxOpenSig = useSignal(false);

  type MyComponents = {
    component: string;
    label: string;
  };

  const docsPrefix = '/docs/headless';
  const components = [
    { component: 'accordion', label: 'Accordion' },
    { component: 'combobox', label: 'Combobox' },
    { component: 'popover', label: 'Popover' },
    { component: 'select', label: 'Select' },
    { component: 'separator', label: 'Separator' },
    { component: 'tabs', label: 'Tabs' },
    { component: 'toggle', label: 'Toggle' },
    { component: 'tooltip', label: 'Tooltip' },
  ];

  return (
    <Combobox
      bind:inputValueSig={inputValueSig}
      bind:inputRef={inputRef}
      bind:highlightedIndexSig={highlightedIndexSig}
      bind:isListboxOpenSig={isListboxOpenSig}
      optionValueKey="component"
      class="w-fit"
      options={components}
    >
      <ComboboxLabel class="text-white">Qwik UI ‚ö°</ComboboxLabel>
      <ComboboxControl class="bg-[#1f2532] rounded-sm border-slate-400 border-[1px] relative">
        <ComboboxInput
          onClick$={() => (isListboxOpenSig.value = !isListboxOpenSig.value)}
          class="pl-6 w-44 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500"
          onKeyDown$={(e) => {
            if (e.key === 'Enter') {
              const inputElement = e.target as HTMLInputElement;
              window.location.href = `${docsPrefix}/${inputElement.value.toLowerCase()}`;
            }
          }}
        />
        <ComboboxTrigger class="w-6 h-6 group absolute left-[4px]">
          <SearchIcon />
        </ComboboxTrigger>
        {inputValueSig.value.length > 0 && (
          // give separate id if two triggers
          <button
            id="close-button"
            aria-label="clear search"
            onMouseDown$={() => {
              inputValueSig.value = '';
              inputRef.value?.focus();
            }}
            class="w-6 h-6 flex justify-center items-center absolute top-0 right-0"
          >
            <ClearIcon class="w-4 h-4" />
          </button>
        )}
      </ComboboxControl>
      <ComboboxPortal>
        <ComboboxListbox
          gutter={8}
          class="w-44 bg-slate-900 px-1 py-2 rounded-sm border-slate-400 border-[1px]"
          hide="escaped"
          optionRenderer$={(option: ResolvedOption, index: number) => {
            const searchOption = option.option as MyComponents;
            return (
              <a
                href={`${docsPrefix}/${searchOption.component}`}
                aria-label={option.label}
              >
                <ComboboxOption
                  key={option.key}
                  class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group flex justify-between items-start gap-4"
                  index={index}
                  resolved={option}
                >
                  <span>{searchOption.label}</span>
                  <span class="scale-[0.9]">
                    {/* this is a Qwik UI docs component */}
                    <StatusBadge
                      status={statusByComponent.headless[option.label]}
                    />
                  </span>
                </ComboboxOption>
              </a>
            );
          }}
        />
      </ComboboxPortal>
    </Combobox>
  );
});

export function SearchIcon(props: QwikIntrinsicElements['svg'], key: string) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="1em"
      height="1em"
      viewBox="0 0 256 256"
      {...props}
      key={key}
    >
      <path
        fill="white"
        d="m228.24 219.76l-51.38-51.38a86.15 86.15 0 1 0-8.48 8.48l51.38 51.38a6 6 0 0 0 8.48-8.48ZM38 112a74 74 0 1 1 74 74a74.09 74.09 0 0 1-74-74Z"
      ></path>
    </svg>
  );
}

export function ClearIcon(props: QwikIntrinsicElements['svg'], key: string) {
  return (
    <svg
      xmlns="http://www.w3.org/2000/svg"
      width="1em"
      height="1em"
      viewBox="0 0 256 256"
      {...props}
      key={key}
    >
      <path
        fill="white"
        d="M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm37.66 130.34a8 8 0 0 1-11.32 11.32L128 139.31l-26.34 26.35a8 8 0 0 1-11.32-11.32L116.69 128l-26.35-26.34a8 8 0 0 1 11.32-11.32L128 116.69l26.34-26.35a8 8 0 0 1 11.32 11.32L139.31 128Z"
      ></path>
    </svg>
  );
}
```
</SearchBar>

This example shows MPA navigation using the Search Bar component. For SPA navigation, use Qwik's [useNavigate](https://qwik.builder.io/docs/api/#usenavigate) hook.

## **Keyboard interactions**

<KeyboardInteractionTable keyDescriptors={
  [
    {
      keyTitle: 'Enter',
      description: `Selects the highlighted option. The listbox closes and the selected option becomes the input's value.`
    },
    {
      keyTitle: 'Down Arrow',
      description: `Opens the listbox and shifts focus to the first option. If focus is already on an option, it moves to the next one. If no next option exists, focus returns to the first option.`,
    },
    {
      keyTitle: 'Up Arrow',
      description: `If focus is on an option, it moves to the previous option. If no previous option exists, focus moves to the last option.`,
    },
    {
      keyTitle: 'Escape',
      description: `Closes the listbox.`,
    },
    {
      keyTitle: 'Home',
      description: `Moves the cursor to the start of the input value when the input is focused. When any listbox option is focused, focus shifts to the first enabled option.`,
    },
    {
      keyTitle: 'End',
      description: `Moves the cursor to the end of the input value when the input is focused. When any listbox option is focused, focus shifts to the last enabled option.`,
    },
    {
      keyTitle: 'Delete',
      description: `Deletes the selected text in the input.`,
    },

]
}/>

## API

The Combobox component API provides a set of properties that allow you to customize the behavior and appearance of the combobox. Here are the notable properties for this component.

### Combobox (Root)

<APITable
  propDescriptors={[
    {
      name: 'options',
      type: 'O[]',
      description: 'An array of options for the combobox.',
    },
    {
      
      name: 'filter$',
      type: 'QRL',
      description: 'A QRL for a custom filter function.',
    },
    {
      name: 'optionValueKey',
      type: 'string',
      description: 'The key for the option value.',
    },
    {
      name: 'optionLabelKey',
      type: 'string',
      description: 'The key for the option label.',
    },
    {
      name: 'optionDisabledKey',
      type: 'string',
      description: 'The key for the disabled option.',
    },
    {
      name: 'defaultLabel',
      type: 'string',
      description: 'The default label for the combobox.',
    },
    {
      name: 'bind:isListboxOpenSig',
      type: `Signal<boolean>`,
      description: 'A signal for the open state of the listbox.',
    },
    {
      name: 'bind:isInputFocusedSig',
      type: 'Signal<boolean>',
      description: 'A signal for the focus state of the input.',
    },
    {
      name: 'bind:inputValueSig',
      type: 'Signal<string>',
      description: 'A signal for the current value of the input.',
    },
    {
      name: 'bind:highlightedIndexSig',
      type: 'Signal<number>',
      description: 'A signal for the highlighted option index.',
    },
  ]}
/>

### ComboboxTrigger

<APITable
  propDescriptors={[
    {
      name: 'onMouseDown$',
      type: 'function',
      description: 'A QRL that toggles the open state of the listbox on mouse down.',
    },
    {
      name: 'tabIndex',
      type: 'number',
      description: 'The tab index of the trigger button. Set to 0 by default.',
    },
  ]}
/>

### ComboboxInput

<APITable
  propDescriptors={[
    {
      name: 'disableOnBlur',
      type: 'boolean',
      description: 'Disables the onBlur event on the input.',
    },
    {
      name: 'onInput$',
      type: 'function',
      description: 'A QRL for handling input events.',
    },
    {
      name: 'onBlur$',
      type: 'function',
      description: 'A QRL for handling blur events.',
    },
    {
      name: 'onKeyDown$',
      type: 'function',
      description: 'A QRL for handling keydown events.',
    },
    {
      name: 'type',
      type: 'string',
      description: 'The type of the input element.',
    },
    {
      name: 'value',
      type: 'string',
      description: 'The current value of the input element.',
    },
    {
      name: 'placeholder',
      type: 'string',
      description: 'The placeholder text for the input element.',
    },
  ]}
/>

### ComboboxPortal

<APITable
  propDescriptors={[
    {
      name: 'elementToTeleport',
      type: 'JSXNode',
      description: 'The children to be rendered inside the portal.',
    },
    {
      name: 'contextIds',
      type: 'Array<string>',
      description: 'An array of context ids to be passed to the portal.',
    },
  ]}
/>

### ComboboxListbox

<APITable
  propDescriptors={[
    {
      name: 'optionRenderer$',
      type: 'QRL',
      description: 'A QRL for rendering the options.',
    },
    {
      name: 'placement',
      type: 'union',
      description: 'The placement of the listbox.',
      info: `"top" | "bottom" | "left" | "right"`
    },
    {
      name: 'gutter',
      type: 'number',
      description: 'The gutter space between the input and the floating element.',
    },
    {
      name: 'flip',
      type: 'boolean',
      description: 'Allows the listbox to flip its position based on available space.',
    },
    {
      name: 'size',
      type: 'boolean',
      description: 'Controls the size of the listbox.',
    },
    {
      name: 'autoPlacement',
      type: 'boolean',
      description: 'Automatically places the listbox based on available space.',
    },
    {
      name: 'hide',
      type: 'union',
      description: 'Allows hiding the listbox when it appears detached from the reference element.',
      info: `"escaped" | "referenceHidden"`
    },
        {
      name: 'ancestorScroll',
      type: 'boolean',
      description: 'Controls the scroll behavior of the listbox.',
    },
    {
      name: 'ancestorResize',
      type: 'boolean',
      description: 'Controls the resize behavior of the listbox.',
    },
    {
      name: 'elementResize',
      type: 'boolean',
      description: 'Controls the resize behavior of the listbox element.',
    },
    {
      name: 'layoutShift',
      type: 'boolean',
      description: 'Controls the layout shift of the listbox.',
    },
    {
      name: 'animationFrame',
      type: 'boolean',
      description: 'Whether to update the position of the listbox on every animation frame.',
    },
  ]}
/>

### ComboboxOption

<APITable
  propDescriptors={[
    {
      name: 'index',
      type: 'number',
      description: 'The index of the option.',
    },
    {
      name: 'resolved',
      type: 'ResolvedOption',
      description: 'The resolved option data.',
      info: `
        option: O;
        key: number;
        value: O extends Record<string, unknown> ? O[ValueKey] : O;
        label: string;
        disabled: boolean;
        lcLabel?: string;
      `
    },
    {
      name: 'onMouseEnter$',
      type: 'function',
      description: 'A QRL for handling mouse enter events.',
    },
    {
      name: 'onClick$',
      type: 'function',
      description: 'A QRL for handling click events.',
    },
  ]}
/>

### ComboboxIcon

<APITable
  propDescriptors={[
    {
      name: 'svg',
      type: 'HTMLOrSVGElement',
      description: 'A custom SVG element wrapped around a span with aria-hidden to be used as the icon. If an SVG is not passed inside, it will use the library default caret icon.',
    },
  ]}
/>





## Additional Examples

### Auto Placement
  
Automatically places the listbox based on available space. **You must set flip to false before using it.**  This comes in handy when you're unsure about the optimal placement for the floating element, or if you prefer not to set it manually.

<AutoPlacementExample>
```tsx 
export const AutoPlacementExample = component$(() => {
  const isListboxOpenSig = useSignal(true);

  type AutoPlacementExample = {
    value: string;
    label: string;
  };

  const autoPlacementExample: Array<AutoPlacementExample> = [
    { value: '0', label: 'Audi üöó' },
    { value: '1', label: 'BMW üöô' },
    { value: '2', label: 'Mercedes üöï' },
    { value: '3', label: 'Tesla üöì' },
  ];

  return (
        <div class="flex flex-col items-center justify-center h-[10rem]">
          <p class="text-white text-center">My Car Collection üöò</p>
          <Combobox
            bind:isListboxOpenSig={isListboxOpenSig}
            class="w-fit"
            options={autoPlacementExample}
            optionDisabledKey="myDisabledKey"
          >
            <ComboboxControl class="bg-[#1f2532] flex items-center rounded-sm border-slate-400 border-[1px] relative mt-2">
              <ComboboxInput class="w-44 px-2 bg-slate-900 px-d2 pr-6 text-white placeholder:text-slate-500" />
              <ComboboxTrigger class="w-6 h-6 group absolute right-0">
                <ComboboxIcon class="stroke-white group-aria-expanded:-rotate-180 transition-transform duration-[450ms]" />
              </ComboboxTrigger>
            </ComboboxControl>
            <ComboboxPortal>
              <ComboboxListbox
                flip={false}
                autoPlacement={true}
                gutter={8}
                class="w-44 bg-slate-900 px-4 py-2 rounded-sm border-slate-400 border-[1px]"
                optionRenderer$={(option: ResolvedOption, index: number) => (
                  <ComboboxOption
                    key={option.key}
                    class="aria-disabled:text-slate-600 aria-disabled:hover:bg-slate-700 rounded-sm px-2 hover:bg-slate-500 aria-selected:bg-slate-500 text-white  border-2 border-transparent aria-selected:border-slate-200 group"
                    index={index}
                    resolved={option}
                  >
                    {option.label}
                  </ComboboxOption>
                )}
              />
            </ComboboxPortal>
          </Combobox>
        </div>
        <div class="w-[calc(100%+200px)] h-[1px]"></div>
  );
});
```
</AutoPlacementExample>

<div class="bg-red-200 dark:bg-red-900 p-4 lg:p-6 rounded-xl dark:border-[#F3F3F3] border-[#333333] shadow-light-medium dark:shadow-dark-medium">
  **NOTE:** You cannot use **flip** and **autoPlacement** at the same time. They both manipulate the placement but with different strategies. Using both can result in a continuous reset loop as they try to override each other's work.
</div>

