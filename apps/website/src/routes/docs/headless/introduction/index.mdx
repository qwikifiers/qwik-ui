---
title: Qwik UI | Introduction
---

import headlessHero from '/public/images/qwik-ui-headless-hero.webp';

# Headless kit

Taking inspiration from popular headless libraries such as [Headless UI](https://headlessui.com/), [Radix UI](https://www.radix-ui.com/primitives/docs/components/accordion), [React Aria](https://react-spectrum.adobe.com/react-aria/components.html), [Kobalte](https://kobalte.dev/docs/core/overview/introduction), and [Melt UI](https://melt-ui.com/docs/builders/accordion), the headless kit is a library of completely unstyled, accessible, and resumable components with built-in structure, behavior, and state.
You can use it to build your design system from scratch with any of the tools you want, or simply use the docs as a reference to the components API if you're using the styled kit.

<Note status="warning">
  Qwik UI is in its **beta** phase - it's like a roller coaster, thrilling and full of
  surprises! Expect new features and some breaking changes until we reach version 1.0. So,
  buckle up and enjoy the ride. üèçÔ∏è
</Note>

## Vision

In 2024, developers should not have to recreate the same [WAI-Aria Patterns](https://www.w3.org/WAI/ARIA/apg/patterns/) from scratch. Building custom components is challenging, and developers shouldn't need to reinvent common UI patterns.

Our aim is to ensure Qwik UI is not just an effective, but also a simple, reliable, and flexible choice for developing applications.

Qwik UI Headless is optimized to squeeze every possible ounce of performance out of Qwik _(Like lemonade from lemons that had a run-in with a steamroller.)_ ü•§

## Why Qwik UI Headless?

### The client and the server

Like Qwik itself, Qwik UI is super performant because it renders everything it can on the server

Unlike many other solutions that focus solely on client-side components, Qwik UI takes advantage of the server, the client, and the concept of resumability.

This means that Qwik UI can operate with any meta-framework that supports Qwik, including the full framework benefits. At the time of writing, that includes [Qwik City](https://qwik.builder.io/docs/qwikcity/) and [Astro](https://astro.build/).

### Embracing native first

Qwik values HTML as the source of truth, and this principle extends to Qwik UI components. We appreciate and adopt the excellent work done by the [Open UI Group](https://open-ui.org/) when appropriate.

This approach also encompasses future native APIs. Users of Qwik UI might find themselves using components that can be gradually adopted into the native specification. This implies that, eventually, these custom patterns might not need any JavaScript.

> For instance, [Qwik UI's popover component](https://github.com/qwikifiers/qwik-ui/pull/445) uses the native Popover API on supported browsers. The Anchor API is also incrementally adoptable.

Thanks to resumability, we do less work because there are less components to execute. With Qwik UI we build on top of that, providing the same functionality with less code needed to prefetch in the first place.

## Features

### Unstyled

Qwik UI is a headless library, and comes with zero or very minimal styling. This means the design of your components are completely customizable.

<CodeSnippet name="headless-jsx" />

This is in contrast to styled libraries such as Bootstrap or Material UI, where [styles often need to be stripped](https://www.smashingmagazine.com/2022/05/you-dont-need-ui-framework/) in order to be custom.

<CodeSnippet name="headless-css.css" />

### Accessible at its core

Everyone should have equal access to information and functionality on the web. Every Qwik UI component is designed to follow the [WCAG Guidelines](https://www.w3.org/WAI/standards-guidelines/wcag/).

However, it's a common misconception that meeting WCAG success criteria guarantees full accessibility of your components. Unfortunately, this is not the case.

The ultimate measure of your components' accessibility is user testing. This aspect, often overlooked in other projects, is a high priority for us.

### Developer Experience that matches UX

Many libraries tout their excellent Developer Experience (DX), but this doesn't necessarily translate into a superior User Experience (UX).

Conversely, some packages offer great UX, but fall short when it comes to DX.

One of the benefits of Qwik is its ability to create performant applications without compromising on DX. Our goal is to extend this same balance of performance and ease-of-use to those utilizing Qwik UI components.

#### Some examples being:

<FeatureList
  features={[
    'TypeScript support',
    'Custom Signal Binds',
    'Automatic entry and exit animations across browsers',
    'Works across environments / microfrontends',
    'Automatic performance optimization',
  ]}
/>

## FAQ

<Accordion>
  <AccordionItem>
    <AccordionTrigger class="pb-4 *:mb-0">
      What kind of support or resources are available if I encounter issues with Qwik UI?
    </AccordionTrigger>
    <AccordionContent>
      If you stumble into any problems, [create an
      issue](https://github.com/qwikifiers/qwik-ui/issues) on the Qwik UI repository. We
      also have a [discord community](https://discord.gg/PVWUUejrez) with a Qwik UI
      channel where you can raise any concerns, propose ideas, or chat all things Qwik UI
      üòä
    </AccordionContent>
  </AccordionItem>
  <AccordionItem>
    <AccordionTrigger>How can I contribute to the project?</AccordionTrigger>
    <AccordionContent>
      We provide a [contributing](/docs/headless/contributing) guide to help get familiar
      with the repository. Additionally, we offer a quick start [setup
      guide](https://github.com/qwikifiers/qwik-ui/blob/main/CONTRIBUTING.md) and a
      section dedicated to advanced resources below the Components navigation.
    </AccordionContent>
  </AccordionItem>
  <AccordionItem>
    <AccordionTrigger class="pb-4 *:mb-0">
      How can I migrate my existing application to use Qwik UI?
    </AccordionTrigger>
    <AccordionContent>
      If you're using Microfrontends, `Qwik-React`, `Qwik-Angular`, `@qwikdev/astro`, we
      suggest incrementally adding Qwik UI components to your application. Qwik, has a
      primitive called containers, and was built from the ground up as a microfrontend.
      This allows you to incrementally integrate Qwik UI components into your existing
      application. This approach reduces migration risk and complexity, letting you
      leverage Qwik UI's benefits at your own pace.
    </AccordionContent>
  </AccordionItem>
</Accordion>

## Credits

We strongly believe in having a [learner's mindset](https://www.jakeyou.com/blog/learners-mindset-how-to-be-a-learner), and as such, we've drawn inspiration from a multitude of projects, learning from their successes and challenges.

Qwik UI's development has been shaped by the following remarkable projects:

- [Radix UI](https://www.radix-ui.com/)
- [Kobalte](https://kobalte.dev/docs/core/overview/introduction)
- [Melt UI](https://www.melt-ui.com/docs/introduction)
- [React Aria](https://react-spectrum.adobe.com/react-aria/)
- [Reach UI](https://reach.tech/)
